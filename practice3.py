"""
8은 특별해!

가로, 세로로 가운데를 갈라도 모두 같은 모양인 8을 좋아하는 엘리스 토끼는 1부터 10000까지 8이라는 숫자가 몇 번 나오는지 알아보려고 해요!

지시사항을 참고하여 코드를 작성하세요.


지시사항
1부터 10,000까지의 수 중 8의 개수를 세어 count에 저장하세요.
"""
count = 0

i = 1

while i < 10001 :
    count = count + str(i).count('8')
    i = i + 1

print(count)


"""
렌터카

엘리스 토끼는 제주도에 놀러 와 H 시간만큼 렌터카를 빌리려고 합니다. 제주도의 대표 렌터카 업체인 모자장수 렌터카와 코더랜드 렌터카는 모두 같은 차량을 제공하고 있지만, 이용 요금에 차이가 있어 가격을 비교해보려고 합니다.

렌터카 업체 요금 정보는 아래와 같습니다.

회사명 요금
모자장수 렌터카	1시간당 A 원에 사용
코더랜드 렌터카	기본요금 B 원에 기본 C 시간 사용,
C 시간이 넘어가면 시간당 D 원의 추가 요금 부과

지시사항을 참고하여 코드를 작성하세요.

지시사항
1. 엘리스 토끼가 렌터카를 이용할 시간을 입력받아 변수 H에 저장하세요.

2. 모자장수 렌터카의 시간당 비용을 입력받아 변수 A에 저장하세요.

3. 그리고 코더랜드 렌터카의 기본요금, 기본 시간, 기본 시간 이후에 시간당 부과되는 요금을 공백을 구분자로 입력받아 이를 각각 변수 B, C, D에 저장하세요.

4. 두 업체의 정보를 토대로 비교하여 최소 비용을 변수 result에 저장하세요.
"""
H = int(input())
A = int(input())
B, C, D = map(int,input().split( ))

car1 = 0 #모자장수 랜터카
car2 = 0 #코더랜드 랜터카

if H <= C :
    #C시간 이하일 경우
    car1 = A * H
    car2 = B // C * H
    result = min(car1, car2)
    #C시간 이상일 경우
else :
    car1 = A * H
    car2 = B + (H - C) * D
    result = min(car1, car2)

print(result)


"""
암호문 해석하기

에니그마(Enigma, 수수께끼)는 독일군이 전장에서 사용했던 암호 생성 장치입니다.

독일어 알파벳 각각에 대하여 다른 알파벳에 임의로 대응시킨 다음, 이렇게 대응된 알파벳으로 전신 부호를 발송했습니다.

예를 들어 a는 p, b는 q, c는 r에 대응시켜 암호화한 전신을 보낼 때 ‘abc’는 ‘pqr’로 전달됩니다. 해독 코드가 담긴 문서는 사람을 써서 반대편에 미리 전달해두고, 이것을 참고해서 전신을 해독했습니다.

에니그마는 각 알파벳이 대응하는 다른 알파벳의 세트에 따라 같은 단어도 다른 코드로 변환합니다.

지시사항에 따라 두 개의 암호 대응표를 이용하여 암호 코드를 해독하는 파이썬 프로그램을 완성하세요.


지시사항

암호의 알파벳을 키로, 대응하는 알파벳을 값으로 저장한 두 개의 딕셔너리 signal1 과 signal2가 있습니다.

암호문의 형태는 다음과 같습니다.

01011 eowxvqp

우선 01011은 5개의 0과 1로 구성되어 있으므로 암호문이 5개의 알파벳으로 구성된 암호문이라는 것을 알 수 있습니다.

따라서 이 암호문은 5번째 알파벳인 v까지만 해석하며, 6번째 알파벳인 q부터는 해석하지 않고 버립니다.

앞에 0과 1은 같은 자리의 알파벳을 각각 signal1을 이용하여 해석할지, signal2를 이용하여 해석할지를 의미합니다.

위 예시에서 0에 대응하는 e, w는 signal1을 이용하여 해석하고 1에 대응하는 o, x, v는 signal2를 이용하여 해석합니다.

signal1에서 e와 w는 각각 e와 i에 대응하며, signal2에서 o, x, v는 각각 l,c,e에 대응합니다.

따라서 예시의 암호문을 해석하면 elice가 되며 이를 출력하시면 정답입니다.

이처럼 암호문을 문자열로 입력받으면 이를 원문으로 해석한 문자열을 출력하는 프로그램을 완성하세요
"""
# 암호의 알파벳을 키로, 대응하는 원문의 알파벳을 값으로 저장한 딕셔너리입니다.

signal1 = {'a': 'n', 'b': 'd', 'c': 'a', 'd': 'b', 'e': 'e', 'f': 'l', 'g': 'j', 'h': 'o', 'i': 'z', 'j': 'u', 'k': 'y', 'l': 'v', 'm': 'w', 'n': 'q', 'o': 'x', 'p': 'r', 'q': 'p', 'r': 'f', 's': 'g', 't': 't', 'u': 'm', 'v': 'h', 'w': 'i', 'x': 'c', 'y': 'k', 'z': 's'}

signal2 = {'a': 'z', 'b': 'y', 'c': 'x', 'd': 'w', 'e': 'v', 'f': 'u', 'g': 't', 'h': 's', 'i': 'r', 'j': 'q', 'k': 'p', 'l': 'o', 'm': 'n', 'n': 'm', 'o': 'l', 'p': 'k', 'q': 'j', 'r': 'i', 's': 'h', 't': 'g', 'u': 'f', 'v': 'e', 'w': 'd', 'x': 'c', 'y': 'b', 'z': 'a'}

# 지시사항을 참고하여 코드를 작성하세요.

def decode(code):
    code1 = code[0]
    code2 = code[1]
    var = 0
    text = ''
    for i in code1 :
        if i == '0' :
            text = text + signal1[code2[var]]
        else :
            text = text + signal2[code2[var]]
        var = var + 1
    return text

code = input().split( ) # 암호문을 문자열의 형태로 입력받습니다.

text = decode(code)

print(text) # 해독된 문자열을 출력합니다.


"""
"""